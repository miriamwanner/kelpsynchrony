synch_vec <- sm[upper.tri(sm, diag=FALSE)]
dist_vec <- newDistMat[upper.tri(newDistMat, diag=FALSE)]
points(dist_vec, synch_vec, pch=20, cex=0.2, col="lightgrey")
plot(spline_corr$real$predicted$x, spline_corr$real$predicted$y, ylim=c(-1, 1))
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - linear symProbMat
fields::image.plot(1:ncol(symProbMat),1:ncol(symProbMat),symProbMat,col=heat.colors(20))
# colorful matrix of connectivity - linear symProbMatF
fields::image.plot(1:ncol(symProbMatF),1:ncol(symProbMatF),symProbMatF,col=heat.colors(20))
# colorful matrix of connectivity - linear symProbMatF
fields::image.plot(1:ncol(symProbMatF),1:ncol(symProbMatF),symProbMatF,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - linear symProbMatF
fields::image.plot(1:ncol(symProbMatF),1:ncol(symProbMatF),symProbMatF,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
logSymProbMat
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
logSym
# colorful matrix of connectivity - log logSym
p5 <- fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
# colorful matrix of smWaves
p1 <- fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
p2 <- fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
p3 <- fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
p4 <- fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSym
p5 <- fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
p6 <- p1 + p2 + p3 + p4 + p5
p6
p1
grid.arrange(p1, p2, nrow=1)
library(ggplot2)
grid.arrange(p1, p2, nrow=1)
par(mfrow=c(2,2))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
par(mfrow=c(3,2))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
par(mfrow=c(2,3))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
par(mfrow=c(3,2))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
# par(mfrow=c(3,2))
layout(matrix(c(1,2,3,4,5,5), 3, 2, byrow = TRUE))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
?plot
# layout(matrix(c(1,2,3,4,5,5), 3, 2, byrow = TRUE))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20),xlab=(a),ylab="") # axes say "1:ncol(sm)" (change)
# layout(matrix(c(1,2,3,4,5,5), 3, 2, byrow = TRUE))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
par(mfrow=c(3,2))
# layout(matrix(c(1,2,3,4,5,5), 3, 2, byrow = TRUE))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20),xlab="(b)",ylab="") # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20),xlab="(c)",ylab="")
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20),xlab="(d)",ylab="")
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20),xlab="(e)",ylab="")
par(mfrow=c(3,2))
# layout(matrix(c(1,2,3,4,5,5), 3, 2, byrow = TRUE))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20),xlab="(b)",ylab="") # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20),xlab="(c)",ylab="")
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20),xlab="(d)",ylab="")
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20),xlab="(e)",ylab="")
spline_corr = Sncf(newLonLatROMS[,1], newLonLatROMS[,2], kelpDataROMSSites, latlon = TRUE)
plot(spline_corr)
synch_vec <- sm[upper.tri(sm, diag=FALSE)]
dist_vec <- newDistMat[upper.tri(newDistMat, diag=FALSE)]
points(dist_vec, synch_vec, pch=20, cex=0.2, col="lightgrey")
plot(spline_corr)
synch_vec <- sm[upper.tri(sm, diag=FALSE)]
dist_vec <- newDistMat[upper.tri(newDistMat, diag=FALSE)]
points(dist_vec, synch_vec, pch=20, cex=0.2, col="lightgrey")
par(mfrow=c(1,2))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
times <- c(1:ncol(kelpDataROMSSites))
colnames(newLonLatROMS)[1] <- "lon" # rename columns for 'clust' method
colnames(newLonLatROMS)[2] <- "lat"
coords <- as.data.frame(newLonLatROMS)
cleanKelp <- cleandat(data.matrix(kelpDataROMSSites), times, clev=5)$cdat # cleans the data - max cleaning level
matcol <- ncol(cleanKelp)
kelpClust <- clust(dat=cleanKelp,times=1:matcol,coords=coords,method="pearson")
get_clusters(kelpClust)
plotmap(kelpClust)
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
?plotmap
plotmap(kelpClust)
par(mfrow=c(1,2))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
par(mfrow=c(1,2))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
par(mfrow=c(1,2))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
# par(mfrow=c(1,2))
layout(matrix(c(1,2), 1, 2, byrow = TRUE),
widths=c(3,1), heights=c(1,2))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
# par(mfrow=c(1,2))
layout(matrix(c(1,2), 1, 2, byrow = TRUE),
widths=c(2,1), heights=c(1,2))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
# par(mfrow=c(1,2))
layout(matrix(c(1,2), 1, 2, byrow = TRUE),
widths=c(2,1), heights=c(1,1))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
par(mfrow=c(1,2))
# layout(matrix(c(1,2), 1, 2, byrow = TRUE), widths=c(2,1), heights=c(1,1))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
# par(mfrow=c(1,2))
layout(matrix(c(1,2), 1, 2, byrow = TRUE), widths=c(2,1), heights=c(1,1))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
par(mfrow=c(1,2))
# layout(matrix(c(1,2), 1, 2, byrow = TRUE), widths=c(2,1), heights=c(1,1))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
par(mfrow=c(1,2))
# layout(matrix(c(1,2), 1, 2, byrow = TRUE), widths=c(2,1), heights=c(1,1))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust, xlab="b")
par(mfrow=c(1,2))
# layout(matrix(c(1,2), 1, 2, byrow = TRUE), widths=c(2,1), heights=c(1,1))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
datloc <- "../Data/"
# Script for getting the ROMS sites from the kelp data
rm(list=ls())
# location for storing the results
resloc <- "../Results/ROMSKelpData/"
if (!dir.exists(resloc)){
dir.create(resloc, recursive=TRUE)
}
# loading the data
datloc <- "../Data/"
# PREPARING KELP DATA:
# kelpBioOriginal = original kelp data from CSV file
# paddleCoordinates = original paddle coordinates from CSV file
# order.paddle = vector of the sites in order of paddle coordinates
# kelpBioPC = kelp data with sites ordered by paddle coordinate
# whichSitesNA = a vector listing which sites were removed (because they were all NA)
# Matrix for Kelp Biomass
kelpBioOriginal <- read.csv(file=paste0(datloc, "Kelp_Bio_2019_v3.csv"))
paddleCoordinates <- read.csv(file=paste0(datloc, "Paddle_coords.csv"))
order.paddle <- paddleCoordinates$Site_Number
# Biomass ordered by paddle coordinates
kelpBioPC <- kelpBioOriginal[match(order.paddle, kelpBioOriginal$Site),]
# Remove all kelp time series which consist only of NAs
# subtract 1 from the number of columns because the site column will never be NA
whichSitesNA <- which(rowSums(is.na(kelpBioPC)) == ncol(kelpBioPC) - 1)
kelpBioPC <- kelpBioPC[rowSums(is.na(kelpBioPC)) != ncol(kelpBioPC) - 1,]
# Remove all kelp time series which consist only of 0s - remove NA for the row sum
kelpBioPC <- kelpBioPC[rowSums(subset(kelpBioPC, select=-Site), na.rm = TRUE) > 0,]
# PREPARING CONNECTIVITY DATA variables:
# OceanDistanceMatrices = the matrices of connectivity data
# ocean.dist.yearly = the yearly data for the connectivity data
# ocean.dist.mainland = only the mainland data from connectivity data
# numYears = number of years the connectivity data has matrices for
# matList = the list of matrices of connectivity data for each year
# ocean.dist.avg = the average matrix of all the years of connectivity data
# Connectivity data
OceanDistanceMatrices <- readMat(file=paste0(datloc, "OceanDistanceMatrices.mat"))
ocean.dist.yearly <- OceanDistanceMatrices$oceandist.yearly
ocean.dist.mainland <- ocean.dist.yearly[1:62, 1:62, ] # this is a 3D matrix
numYears <- dim(ocean.dist.mainland)[3] # this is the number of years
# for loop that adds each matrix to a list of matrices (to then average after)
matList <- list()
for(i in 1:numYears){
matList[[i]] <- ocean.dist.mainland[,,i]
}
# from the list of matrices, take the average of each corresponding cell in each matrix for an average matrix
ocean.dist.avg <- Reduce('+', matList)/length(matList) # this is the average matrix for all time (over the time the data was collected)
# ============================================= Corresponding Kelp/ROMS sites ============================================
# Getting the kelp data and ROMS cells that are closest together/correspond to one another
# DISTANCE KELP/ROMS SITES variables:
# kelpCoordinates = coordinates of all the kelp sites from CSV file
# romsCoordinates = coordinates of all the ROMS sites from CSV file
# numKelpSites = the number of total kelp sites
# numROMSSites = the number of total ROMS sites
# lonLatKelp = two column matrix of longitude (first column) and latitude (second column) of all kelp sites
# lonLatROMS = two column matrix of longitude (first column) and latitude (second column) of all ROMS sites
# distMat = matrix of the distances between the all kelp and all ROMS sites in kilometer
# vecLocations = ROMS cell that each kelp site corresponds to (index of vector is kelp site)
# minDistForLocations = gives the distance between kelp and ROMS site (index of vector is kelp/ROMS site from vecLocations), NA if greater than 12 km away
# Get coordinates (lat and lon) of kelp and ROMS data in two data frames
kelpCoordinates <- read.csv(file=paste0(datloc, "Data/Paddle_coords.csv"))
kelpCoordinates <- kelpCoordinates[-whichSitesNA, ] # remove the sites that were removed earlier (because the entire time series was NA)
romsCoordinates <- as.data.frame(t(readMat(file=paste0(datloc, "site_centers.mat")))) # this is the center of the coordinates
# Matrix of the distance (the columns are the ROMS sites and the rows are the kelp sites)
numKelpSites <- length(as.vector(kelpCoordinates$Lat))
numROMSSites <- length(as.vector(unlist(romsCoordinates$lat))[1:62])
lonLatKelp <- matrix(c(as.vector(kelpCoordinates$Lon), as.vector(kelpCoordinates$Lat)), ncol = 2)
lonLatROMS <- matrix(c(as.vector(unlist(romsCoordinates$lon))[1:62], as.vector(unlist(romsCoordinates$lat))[1:62]), ncol = 2)
distMat <- distm(lonLatKelp, lonLatROMS, fun = distHaversine) * (0.001) # multiply to get km
vecLocations <- as.matrix(apply(distMat, 1, which.min)) # this will have the ROMS cell that each kelp site corresponds to
minDistForLocations <- vector(,length(vecLocations))
for(i in 1:length(vecLocations)){
minDistForLocations[i] <- distMat[i, vecLocations[i]]
}
# do not use data that is greater than 12 km away (cells have 5 km radius) from the ROMS cell (make this data NA, and will remove from data set later)
for(i in 1:length(minDistForLocations)){
if(minDistForLocations[i] > 12){
minDistForLocations[i] <- NA
vecLocations[i] <- NA
}
}
# KELP/ROMS SITES CORRESPONDING TO EACHOTHER variables:
# ROMSSitesVec = vector of ROMS sites to be used, NA if no kelp data that corresponds to it
# newSites = index is the row number of the kelpDataROMSSites and value is which ROMS cell it corresponds to
# kelpDataROMSSites = kelp data (added when multiple sites fit with the same ROMS site) for the ROMS sites
# oceanAvgKelpSites = ROMS connectivity data, but deleted the sites we aren't using (no kelp site corresponds to it), diagonal is zero
# rowColToDel = the ROMS sites being deleted
# make a vector of ROMS (mainland) cells and make ones NA if there is no kelp data sites that correspond to it
# start with a vector of NA, and just change them if there is a kelp site that corresponds to it
ROMSSitesVec <- rep(NA, 62)
for(i in 1:length(vecLocations)){
ROMSSitesVec[vecLocations[i]] <- vecLocations[i]
}
# Create the data so that the sites now correspond to one another
# new data frame that has all the kelp data, but corresponding to each of the connectivity data, and ordered by connectivity data
newSites <- vector(,43) # index is the row number of the kelpDataROMSSites and value is which ROMS cell it corresponds to
kelpDataROMSSites <- kelpBioPC[0:43,] # first 43 rows, but the data will be replaced with ROMS data
counter <- 0
for(i in 1:nrow(kelpBioPC)){
loc <- which(vecLocations == i)
if(length(loc) != 0){
counter <- counter + 1
newSites[counter] <- i
kelpDataROMSSites[counter,] <- colSums(x = kelpBioPC[loc,], na.rm = TRUE) # / length(loc) # only sum the elements - not average
}
}
# delete rows/columns of the connectivity data
oceanAvgKelpSites <- ocean.dist.avg # originally is the same matrix, but then remove the sites
i <- length(ROMSSitesVec)
while(i >= 1){ # goes through the matrix and sets the row/column to all be na
if(is.na(ROMSSitesVec[i])){
oceanAvgKelpSites[i,] <- NA
oceanAvgKelpSites[,i] <- NA
}
i <- i - 1
}
rowColToDel <- which(is.na(ROMSSitesVec))
oceanAvgKelpSites <- oceanAvgKelpSites[-rowColToDel, -rowColToDel] # removes the columns/rows that have na in them
diag(oceanAvgKelpSites) <- 0 # set the diagonal to zero
# save as .rds or .rdata datafile
# use the command save
# when you load - the vars come into the workspace with the same names
# save rds saves one var as a file name - asign that var to a (if u want) diff var name
save(order.paddle, file = "resloc/order.paddle.RData")
save(whichSitesNA, file = "resloc/whichSitesNA.RData")
save(romsCoordinates, file = "resloc/romsCoordinates.RData")
save(vecLocations, file = "resloc/vecLocations.RData")
save(newSites, file = "resloc/newSites.RData")
save(kelpDataROMSSites, file = "resloc/kelpDataROMSSites.RData")
save(oceanAvgKelpSites, file = "resloc/oceanAvgKelpSites.RData")
library(spatstat)
library(geosphere)
library(wsyn)
library(ecodist)
library(R.matlab)
library(plot3D)
library(RColorBrewer)
library(ggplot2)
library(PBSmapping)
library(plyr)
library(tidyverse)
library(scatterplot3d)
library(rgl)
library(gtools)
library(ncf)
library(ggplot2)
library(mms)
rm(list=ls())
# location for storing the results
resloc <- "../Results/ROMSKelpData/"
if (!dir.exists(resloc)){
dir.create(resloc, recursive=TRUE)
}
# loading the data
datloc <- "../Data/"
rm(list=ls())
# location for storing the results
resloc <- "../Results/ROMSKelpData/"
if (!dir.exists(resloc)){
dir.create(resloc, recursive=TRUE)
}
# loading the data
datloc <- "../Data/"
rm(list=ls())
# location for storing the results
resloc <- "../Results/ROMSKelpData/"
if (!dir.exists(resloc)){
dir.create(resloc, recursive=TRUE)
}
# loading the data
datloc <- "../Data/"
# PREPARING KELP DATA:
# kelpBioOriginal = original kelp data from CSV file
# paddleCoordinates = original paddle coordinates from CSV file
# order.paddle = vector of the sites in order of paddle coordinates
# kelpBioPC = kelp data with sites ordered by paddle coordinate
# whichSitesNA = a vector listing which sites were removed (because they were all NA)
# Matrix for Kelp Biomass
kelpBioOriginal <- read.csv(file=paste0(datloc, "Kelp_Bio_2019_v3.csv"))
paddleCoordinates <- read.csv(file=paste0(datloc, "Paddle_coords.csv"))
order.paddle <- paddleCoordinates$Site_Number
# Biomass ordered by paddle coordinates
kelpBioPC <- kelpBioOriginal[match(order.paddle, kelpBioOriginal$Site),]
# Remove all kelp time series which consist only of NAs
# subtract 1 from the number of columns because the site column will never be NA
whichSitesNA <- which(rowSums(is.na(kelpBioPC)) == ncol(kelpBioPC) - 1)
kelpBioPC <- kelpBioPC[rowSums(is.na(kelpBioPC)) != ncol(kelpBioPC) - 1,]
# Remove all kelp time series which consist only of 0s - remove NA for the row sum
kelpBioPC <- kelpBioPC[rowSums(subset(kelpBioPC, select=-Site), na.rm = TRUE) > 0,]
# PREPARING CONNECTIVITY DATA variables:
# OceanDistanceMatrices = the matrices of connectivity data
# ocean.dist.yearly = the yearly data for the connectivity data
# ocean.dist.mainland = only the mainland data from connectivity data
# numYears = number of years the connectivity data has matrices for
# matList = the list of matrices of connectivity data for each year
# ocean.dist.avg = the average matrix of all the years of connectivity data
# Connectivity data
OceanDistanceMatrices <- readMat(file=paste0(datloc, "OceanDistanceMatrices.mat"))
ocean.dist.yearly <- OceanDistanceMatrices$oceandist.yearly
ocean.dist.mainland <- ocean.dist.yearly[1:62, 1:62, ] # this is a 3D matrix
numYears <- dim(ocean.dist.mainland)[3] # this is the number of years
# for loop that adds each matrix to a list of matrices (to then average after)
matList <- list()
for(i in 1:numYears){
matList[[i]] <- ocean.dist.mainland[,,i]
}
# from the list of matrices, take the average of each corresponding cell in each matrix for an average matrix
ocean.dist.avg <- Reduce('+', matList)/length(matList) # this is the average matrix for all time (over the time the data was collected)
# ============================================= Corresponding Kelp/ROMS sites ============================================
# Getting the kelp data and ROMS cells that are closest together/correspond to one another
# DISTANCE KELP/ROMS SITES variables:
# kelpCoordinates = coordinates of all the kelp sites from CSV file
# romsCoordinates = coordinates of all the ROMS sites from CSV file
# numKelpSites = the number of total kelp sites
# numROMSSites = the number of total ROMS sites
# lonLatKelp = two column matrix of longitude (first column) and latitude (second column) of all kelp sites
# lonLatROMS = two column matrix of longitude (first column) and latitude (second column) of all ROMS sites
# distMat = matrix of the distances between the all kelp and all ROMS sites in kilometer
# vecLocations = ROMS cell that each kelp site corresponds to (index of vector is kelp site)
# minDistForLocations = gives the distance between kelp and ROMS site (index of vector is kelp/ROMS site from vecLocations), NA if greater than 12 km away
# Get coordinates (lat and lon) of kelp and ROMS data in two data frames
kelpCoordinates <- read.csv(file=paste0(datloc, "Data/Paddle_coords.csv"))
kelpCoordinates <- kelpCoordinates[-whichSitesNA, ] # remove the sites that were removed earlier (because the entire time series was NA)
romsCoordinates <- as.data.frame(t(readMat(file=paste0(datloc, "site_centers.mat")))) # this is the center of the coordinates
# Matrix of the distance (the columns are the ROMS sites and the rows are the kelp sites)
numKelpSites <- length(as.vector(kelpCoordinates$Lat))
numROMSSites <- length(as.vector(unlist(romsCoordinates$lat))[1:62])
lonLatKelp <- matrix(c(as.vector(kelpCoordinates$Lon), as.vector(kelpCoordinates$Lat)), ncol = 2)
lonLatROMS <- matrix(c(as.vector(unlist(romsCoordinates$lon))[1:62], as.vector(unlist(romsCoordinates$lat))[1:62]), ncol = 2)
distMat <- distm(lonLatKelp, lonLatROMS, fun = distHaversine) * (0.001) # multiply to get km
vecLocations <- as.matrix(apply(distMat, 1, which.min)) # this will have the ROMS cell that each kelp site corresponds to
minDistForLocations <- vector(,length(vecLocations))
for(i in 1:length(vecLocations)){
minDistForLocations[i] <- distMat[i, vecLocations[i]]
}
# do not use data that is greater than 12 km away (cells have 5 km radius) from the ROMS cell (make this data NA, and will remove from data set later)
for(i in 1:length(minDistForLocations)){
if(minDistForLocations[i] > 12){
minDistForLocations[i] <- NA
vecLocations[i] <- NA
}
}
# KELP/ROMS SITES CORRESPONDING TO EACHOTHER variables:
# ROMSSitesVec = vector of ROMS sites to be used, NA if no kelp data that corresponds to it
# newSites = index is the row number of the kelpDataROMSSites and value is which ROMS cell it corresponds to
# kelpDataROMSSites = kelp data (added when multiple sites fit with the same ROMS site) for the ROMS sites
# oceanAvgKelpSites = ROMS connectivity data, but deleted the sites we aren't using (no kelp site corresponds to it), diagonal is zero
# rowColToDel = the ROMS sites being deleted
# make a vector of ROMS (mainland) cells and make ones NA if there is no kelp data sites that correspond to it
# start with a vector of NA, and just change them if there is a kelp site that corresponds to it
ROMSSitesVec <- rep(NA, 62)
for(i in 1:length(vecLocations)){
ROMSSitesVec[vecLocations[i]] <- vecLocations[i]
}
# Create the data so that the sites now correspond to one another
# new data frame that has all the kelp data, but corresponding to each of the connectivity data, and ordered by connectivity data
newSites <- vector(,43) # index is the row number of the kelpDataROMSSites and value is which ROMS cell it corresponds to
kelpDataROMSSites <- kelpBioPC[0:43,] # first 43 rows, but the data will be replaced with ROMS data
counter <- 0
for(i in 1:nrow(kelpBioPC)){
loc <- which(vecLocations == i)
if(length(loc) != 0){
counter <- counter + 1
newSites[counter] <- i
kelpDataROMSSites[counter,] <- colSums(x = kelpBioPC[loc,], na.rm = TRUE) # / length(loc) # only sum the elements - not average
}
}
# delete rows/columns of the connectivity data
oceanAvgKelpSites <- ocean.dist.avg # originally is the same matrix, but then remove the sites
i <- length(ROMSSitesVec)
while(i >= 1){ # goes through the matrix and sets the row/column to all be na
if(is.na(ROMSSitesVec[i])){
oceanAvgKelpSites[i,] <- NA
oceanAvgKelpSites[,i] <- NA
}
i <- i - 1
}
rowColToDel <- which(is.na(ROMSSitesVec))
oceanAvgKelpSites <- oceanAvgKelpSites[-rowColToDel, -rowColToDel] # removes the columns/rows that have na in them
diag(oceanAvgKelpSites) <- 0 # set the diagonal to zero
# save as .rds or .rdata datafile
# use the command save
# when you load - the vars come into the workspace with the same names
# save rds saves one var as a file name - asign that var to a (if u want) diff var name
pwd
pwd()
getwd
getwd()
setwd("/Users/miriam/Documents/Github/kelpsynchrony/") # needs to be changed
getwd()
getrm(list=ls())
getrm
? getrm
setwd("/Users/miriam/Documents/Github/kelpsynchrony/") # needs to be changed
rm(list=ls())
resloc <- "../Results/ROMSKelpData/"
if (!dir.exists(resloc)){
dir.create(resloc, recursive=TRUE)
}
datloc <- "../Data/"
# Matrix for Kelp Biomass
kelpBioOriginal <- read.csv(file=paste0(datloc, "Kelp_Bio_2019_v3.csv"))

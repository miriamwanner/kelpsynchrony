lessConnected2 <- vector(,69)
countMoreConnected2 <- 0
countLessConnected2 <- 0
for(i in 1:nrow(newDistMat)){
for(j in 1:ncol(newDistMat)){
if(newDistMat[i, j] <= 12){
if(log10(probMatFecundity[i, j]) > -3){
countMoreConnected2 <- countMoreConnected2 + 1
moreConnected2[countMoreConnected2] <- sm[i, j]
}
else{
countLessConnected2 <- countLessConnected2 + 1
lessConnected2[countLessConnected2] <- sm[i, j]
}
}
}
}
# plot that evenly spaces the points along the x axis
plot(1:length(moreConnected2), moreConnected2, xlim=c(0,70))
points(1:length(lessConnected2), lessConnected2, col = "blue")
# plot that stacks the points on top of one another
plot(c(rep(1, 40)) , moreConnected2, xlim=c(0,3))
points(c(rep(2, 69)), lessConnected2, col = "blue")
boxplot(c(moreConnected2,lessConnected2) ~ c(rep(1,40),rep(2,69)))
# SYMMETRIC PROBABILITY MATRIX variables:
# symProbMat = a symmetric matrix of probMat matrix by just using the max of [i, j] and [j, i] from probMat
# logSymProbMat = the log10 of the symProbMat matrix - diagonal is 1
symProbMat <- pmax(probMat, t(probMat))
logSymProbMat <- log10(symProbMat)
diag(logSym) <- 1
# New code for 4/20/21
# WAVES DATA variables:
# waves = the original waves data
# wavesPC = wave data ordered by paddle coordinate
# wavesROMSSites = wave data that matches up to the ROMS sites
# read in the waves data
waves <- read.csv("/Users/miriam/Documents/GitHub/kelpsynchrony/Data/Hs_Max_2019.csv")
wavesPC <- waves[match(order.paddle, waves$Site),]
wavesPC <- wavesPC[-whichSitesNA]
# get the waves sites to line up with the ROMS sites (same way as kelp sites)
wavesROMSSites <- wavesPC[0:43,]
counter <- 0
for(i in 1:nrow(wavesPC)){
loc <- which(vecLocations == i)
if(length(loc) != 0){
counter <- counter + 1
wavesROMSSites[counter,] <- colSums(x = wavesPC[loc,], na.rm = TRUE) / length(loc)
# should I average or add for waves? I think average because it is with height
}
}
# WAVES SYNCHRONY MATRIX variables:
# timesWaves = the times that will be passed into cleandat
# matWaves = the matrix created from the dataframe wavesROMSSites
# cleanWaves = the cleaned wave data using cleandat
# waveCol = the number of columns in the clean wave data
# smWaves = the synchrony matrix created from the clean wave data
# wave data for the synchrony matrix of wave data
wavesROMSSites <- subset(wavesROMSSites, select=-Site) # remove the 'Site' column
timesWaves <- c(1:ncol(wavesROMSSites)) # this is the times that will be passed into cleandat
matWaves <- data.matrix(wavesROMSSites) # creates the matrix from the dataframe
cleanWaves <- cleandat(matWaves, timesWaves, clev=2)$cdat # cleans the data - 2 is enough
waveCol <- ncol(cleanWaves)
smWaves <- synmat(cleanWaves, 1:waveCol, method="pearson")
diag(smWaves) <- 1
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
fields::image.plot(1:ncol(symProbMat),1:ncol(symProbMat),symProbMat,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# NITRATE DATA variables:
# NO3 = the original nitrate data
# NO3PC = nitrate data ordered by paddle coordinate
# NO3ROMSSites = nitrate data that matches up to the ROMS sites
# read in the waves data
NO3 <- read.csv("/Users/miriam/Documents/GitHub/kelpsynchrony/Data/NO3_Mean_2019.csv")
NO3PC <- NO3[match(order.paddle, NO3$Site),]
NO3PC <- NO3PC[-whichSitesNA]
# get the nitrate sites to line up with the ROMS sites (same way as kelp sites)
NO3ROMSSites <- NO3PC[0:43,]
counter <- 0
for(i in 1:nrow(NO3PC)){
loc <- which(vecLocations == i)
if(length(loc) != 0){
counter <- counter + 1
NO3ROMSSites[counter,] <- colSums(x = NO3PC[loc,], na.rm = TRUE) / length(loc)
# should I average or add for nitrate?
}
}
# NITRATE SYNCHRONY MATRIX variables:
# timesNO3 = the times that will be passed into cleandat
# matNO3 = the matrix created from the dataframe NO3ROMSSites
# cleanNO3 = the cleaned nitrate data using cleandat
# NO3Col = the number of columns in the clean nitrate data
# smNO3 = the synchrony matrix created from the clean nitrate data
# nitrate data for the synchrony matrix of nitrate data
NO3ROMSSites <- subset(NO3ROMSSites, select=-Site) # remove the 'Site' column
timesNO3 <- c(1:ncol(NO3ROMSSites)) # this is the times that will be passed into cleandat
matNO3 <- data.matrix(NO3ROMSSites) # creates the matrix from the dataframe
cleanNO3 <- cleandat(matNO3, timesNO3, clev=2)$cdat # cleans the data - 2 is enough
NO3Col <- ncol(cleanNO3)
smNO3 <- synmat(cleanNO3, 1:NO3Col, method="pearson")
diag(smNO3) <- 1
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# USE MRM TO SEE CORRELATION BETWEEN SYNCHRONY AND SYMMETRIC PROBABILITY MATRIX:
MRM(as.dist(sm) ~ as.dist(logSym) + as.dist(newDistMat) + as.dist(smNO3))
MRM(as.dist(sm) ~ as.dist(logSym))
MRM(as.dist(sm) ~ as.dist(symProbMatF) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
MRM(as.dist(sm) ~ as.dist(logSym) + as.dist(newDistMat))
MRM(as.dist(sm) ~ as.dist(logSym) + as.dist(smNO3))
MRM(as.dist(sm) ~ as.dist(symProbMatF) + as.dist(smNO3))
MRM(as.dist(sm) ~ as.dist(newDistMat) + as.dist(logSym))
MRM(as.dist(sm) ~ as.dist(logSym))
MRM(as.dist(sm) ~ as.dist(newDistMat))
# PLOT 3D SCATTER PLOT
# x-axis: distances
# y-axis: log10(symProbMatF)
# z-axis: synchrony
distPlot <- as.vector(newDistMat)
probPlot <- as.vector(logSym)
synchPlot <- as.vector(sm)
nitratePlot <- as.vector(smNO3)
wavesPlot <- as.vector(smWaves)
plot(x=nitratePlot, y=synchPlot)
scatter3D(xDist, yProb, zSync, xlab = "distance", ylab = "symProbMatF", zlab = "synchrony")
scatterplot3d(x=xDist, y=yProb, z=zSync)
options(rgl.printRglwidget = TRUE)
plot3d(x=xDist, y=yProb, z=zSync)
plot3d(x=xDist[xDist < 17], y=yProb[xDist < 17], z=zSync[xDist < 17])
zWaveSync <- as.vector(smWaves)
plot3d(x=xDist, y=yProb, z=zWaveSync)
zNO3Sync <- as.vector(smNO3)
plot3d(x=xDist, y=yProb, z=zNO3Sync)
times <- c(1:ncol(kelpDataROMSSites))
colnames(newLonLatROMS)[1] <- "lon" # rename columns for 'clust' method
colnames(newLonLatROMS)[2] <- "lat"
coords <- as.data.frame(newLonLatROMS)
cleanKelp <- cleandat(data.matrix(kelpDataROMSSites), times, clev=5)$cdat # cleans the data - max cleaning level
matcol <- ncol(cleanKelp)
kelpClust <- clust(dat=cleanKelp,times=1:matcol,coords=coords,method="pearson")
get_clusters(kelpClust)
plotmap(kelpClust)
# creating wavelet mean fields for each module and plot
kelpClust <- addwmfs(kelpClust)
plotmag(get_wmfs(kelpClust)[[3]][[1]]) # I do not understand the indexing here but I just copied it from the vignette
plotmag(get_wmfs(kelpClust)[[3]][[2]])
plotmag(get_wmfs(kelpClust)[[3]][[3]])
# clustering without the sites 41-43
kelpDataROMSSites40 <- kelpDataROMSSites[-c(1, 43), ]
newLonLatROMS40 <- newLonLatROMS[-c(1, 43), ]
times40 <- c(1:ncol(kelpDataROMSSites40))
colnames(newLonLatROMS40)[1] <- "lon" # rename columns for 'clust' method
colnames(newLonLatROMS40)[2] <- "lat"
coords40 <- as.data.frame(newLonLatROMS40)
cleanKelp40 <- cleandat(data.matrix(kelpDataROMSSites40), times40, clev=5)$cdat # cleans the data - max cleaning level
matcol <- ncol(cleanKelp40)
kelpClust40 <- clust(dat=cleanKelp40,times=1:matcol,coords=coords40,method="pearson")
get_clusters(kelpClust40)
plotmap(kelpClust40)
# creating wavelet mean fields for each module and plot
kelpClust40 <- addwmfs(kelpClust40)
plotmag(get_wmfs(kelpClust40)[[3]][[1]]) # I do not understand the indexing here but I just copied it from the vignette
plotmag(get_wmfs(kelpClust40)[[3]][[2]])
plotmag(get_wmfs(kelpClust40)[[3]][[3]])
# logit transform
diag(sm) <- NA
logit_sm <- logit(sm, min=-1, max=1)
diag(sm) <- 1
# vector_logit_sm = logit_sm[upper.tri(logit_sm, diag=FALSE)]
# logit_max = max(vector_logit_sm)
# diag(logit_sm) <- logit_max
# linear - transport: symProbMat, connectivity: symProbMatF
# log - transport: logSymProbMat, connectivity: logSym
# logit: logit_sm, not logit: sm
MRM(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
# spline correlogram
spline_corr = Sncf(newLonLatROMS[,1], newLonLatROMS[,2], kelpDataROMSSites, latlon = TRUE)
plot(spline_corr)
synch_vec <- sm[upper.tri(sm, diag=FALSE)]
dist_vec <- newDistMat[upper.tri(newDistMat, diag=FALSE)]
points(dist_vec, synch_vec, pch=20, cex=0.2, col="lightgrey")
plot(spline_corr$real$predicted$x, spline_corr$real$predicted$y, ylim=c(-1, 1))
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - linear symProbMat
fields::image.plot(1:ncol(symProbMat),1:ncol(symProbMat),symProbMat,col=heat.colors(20))
# colorful matrix of connectivity - linear symProbMatF
fields::image.plot(1:ncol(symProbMatF),1:ncol(symProbMatF),symProbMatF,col=heat.colors(20))
# colorful matrix of connectivity - linear symProbMatF
fields::image.plot(1:ncol(symProbMatF),1:ncol(symProbMatF),symProbMatF,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - linear symProbMatF
fields::image.plot(1:ncol(symProbMatF),1:ncol(symProbMatF),symProbMatF,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
logSymProbMat
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
logSym
# colorful matrix of connectivity - log logSym
p5 <- fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
# colorful matrix of smWaves
p1 <- fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
p2 <- fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
p3 <- fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
p4 <- fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSym
p5 <- fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
p6 <- p1 + p2 + p3 + p4 + p5
p6
p1
grid.arrange(p1, p2, nrow=1)
library(ggplot2)
grid.arrange(p1, p2, nrow=1)
par(mfrow=c(2,2))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
par(mfrow=c(3,2))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
par(mfrow=c(2,3))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
par(mfrow=c(3,2))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
# par(mfrow=c(3,2))
layout(matrix(c(1,2,3,4,5,5), 3, 2, byrow = TRUE))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20))
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20))
?plot
# layout(matrix(c(1,2,3,4,5,5), 3, 2, byrow = TRUE))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20),xlab=(a),ylab="") # axes say "1:ncol(sm)" (change)
# layout(matrix(c(1,2,3,4,5,5), 3, 2, byrow = TRUE))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
par(mfrow=c(3,2))
# layout(matrix(c(1,2,3,4,5,5), 3, 2, byrow = TRUE))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20),xlab="(b)",ylab="") # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20),xlab="(c)",ylab="")
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20),xlab="(d)",ylab="")
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20),xlab="(e)",ylab="")
par(mfrow=c(3,2))
# layout(matrix(c(1,2,3,4,5,5), 3, 2, byrow = TRUE))
# colorful matrix of smWaves
fields::image.plot(1:ncol(smWaves),1:ncol(smWaves),smWaves,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
# colorful matrix of smNO3
fields::image.plot(1:ncol(smNO3),1:ncol(smNO3),smNO3,col=heat.colors(20),xlab="(b)",ylab="") # axes say "1:ncol(sm)" (change)
# colorful matrix of newDistMat
fields::image.plot(1:ncol(newDistMat),1:ncol(newDistMat),newDistMat,col=heat.colors(20),xlab="(c)",ylab="")
# colorful matrix of connectivity - log logSymProbMat
diag(logSymProbMat) <- 0
fields::image.plot(1:ncol(logSymProbMat),1:ncol(logSymProbMat),logSymProbMat,col=heat.colors(20),xlab="(d)",ylab="")
# colorful matrix of connectivity - log logSym
fields::image.plot(1:ncol(logSym),1:ncol(logSym),logSym,col=heat.colors(20),xlab="(e)",ylab="")
spline_corr = Sncf(newLonLatROMS[,1], newLonLatROMS[,2], kelpDataROMSSites, latlon = TRUE)
plot(spline_corr)
synch_vec <- sm[upper.tri(sm, diag=FALSE)]
dist_vec <- newDistMat[upper.tri(newDistMat, diag=FALSE)]
points(dist_vec, synch_vec, pch=20, cex=0.2, col="lightgrey")
plot(spline_corr)
synch_vec <- sm[upper.tri(sm, diag=FALSE)]
dist_vec <- newDistMat[upper.tri(newDistMat, diag=FALSE)]
points(dist_vec, synch_vec, pch=20, cex=0.2, col="lightgrey")
par(mfrow=c(1,2))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20)) # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
times <- c(1:ncol(kelpDataROMSSites))
colnames(newLonLatROMS)[1] <- "lon" # rename columns for 'clust' method
colnames(newLonLatROMS)[2] <- "lat"
coords <- as.data.frame(newLonLatROMS)
cleanKelp <- cleandat(data.matrix(kelpDataROMSSites), times, clev=5)$cdat # cleans the data - max cleaning level
matcol <- ncol(cleanKelp)
kelpClust <- clust(dat=cleanKelp,times=1:matcol,coords=coords,method="pearson")
get_clusters(kelpClust)
plotmap(kelpClust)
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
?plotmap
plotmap(kelpClust)
par(mfrow=c(1,2))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
par(mfrow=c(1,2))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
par(mfrow=c(1,2))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
# par(mfrow=c(1,2))
layout(matrix(c(1,2), 1, 2, byrow = TRUE),
widths=c(3,1), heights=c(1,2))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
# par(mfrow=c(1,2))
layout(matrix(c(1,2), 1, 2, byrow = TRUE),
widths=c(2,1), heights=c(1,2))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
# par(mfrow=c(1,2))
layout(matrix(c(1,2), 1, 2, byrow = TRUE),
widths=c(2,1), heights=c(1,1))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
par(mfrow=c(1,2))
# layout(matrix(c(1,2), 1, 2, byrow = TRUE), widths=c(2,1), heights=c(1,1))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
# par(mfrow=c(1,2))
layout(matrix(c(1,2), 1, 2, byrow = TRUE), widths=c(2,1), heights=c(1,1))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
par(mfrow=c(1,2))
# layout(matrix(c(1,2), 1, 2, byrow = TRUE), widths=c(2,1), heights=c(1,1))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
par(mfrow=c(1,2))
# layout(matrix(c(1,2), 1, 2, byrow = TRUE), widths=c(2,1), heights=c(1,1))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust, xlab="b")
par(mfrow=c(1,2))
# layout(matrix(c(1,2), 1, 2, byrow = TRUE), widths=c(2,1), heights=c(1,1))
fields::image.plot(1:ncol(sm),1:ncol(sm),sm,col=heat.colors(20),xlab="(a)",ylab="") # axes say "1:ncol(sm)" (change)
plotmap(kelpClust)
source("altered_mrm_function.R")
setwd("/Users/miriam/Documents/Github/kelpsynchrony/Code/") # needs to be changed
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
my_mrm(as.dist(sm) ~ as.dist(newDistMat))
?MRM
# get the ROMS cells corresponding to the kelp data
source("get_ROMS_from_kelp.R")
source("create_synchrony_matrices.R")
source("intermediate_figures.R") # includes possible figures for the appendix
source("final_figures.R")
?eval
MRM(as.dist(sm) ~ as.dist(symProbMatF) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
print(m2)
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
?model.frame
print(model.frame)
getAnywhere(model.frame)
getMethod(model.frame)
?UseMethod
?formula
model.frame
MRM
model.frame
?function
q
?UseMethod
UseMethod
R.Version
R.Version()
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
View(as.dist(sm))
as.dist(sm)
?as.dist
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
?formula
as.formula(as.dist(sm) ~ as.dist(newDistMat))
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
as.formula(as.dist(sm) ~ as.dist(newDistMat))
model.frame(formula = as.formula(as.dist(sm) ~ as.dist(newDistMat)))
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
as.dist(sm)
sum(is.na(as.dist(sm)))
model.frame(formula = as.formula(as.dist(sm) ~ as.dist(newDistMat)))
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
?as.name
an <- as.name("arrg")
an
m[[1]]
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
model.frame(as.dist(sm))
model.frame(as.dist(sm) ~ as.dist(newDistMat))
model.frame(as.dist(sm) + as.dist(newDistMat))
model.frame(as.vector(sm) + as.vector(newDistMat))
model.frame(as.vector(sm) ~ as.vector(newDistMat))
?formula
as.vector(as.dist(sm))
source("altered_mrm_function.R")
# anytime i call MRM, also call my_mrm and make sure the results are the same
my_mrm(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
source("altered_mrm_function.R")
my_mrm(as.vector(as.dist(sm)) ~ as.vector(as.dist(symProbMat)) + as.vector(as.dist(newDistMat)) + as.vector(as.dist(smWaves)) + as.vector(as.dist(smNO3)))
MRM(as.vector(as.dist(sm)) ~ as.vector(as.dist(symProbMat)) + as.vector(as.dist(newDistMat)) + as.vector(as.dist(smWaves)) + as.vector(as.dist(smNO3)))
MRM(as.dist(sm) ~ as.dist(symProbMat) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
?MRM
MRM
my_mrm(as.vector(as.dist(logit_sm)) ~ as.vector(as.dist(symProbMat)) + as.vector(as.dist(newDistMat)) + as.vector(as.dist(smWaves)) + as.vector(as.dist(smNO3)))
# logit transform
diag(sm) <- NA
logit_sm <- logit(sm, min=-1, max=1)
diag(sm) <- 1
my_mrm(as.vector(as.dist(logit_sm)) ~ as.vector(as.dist(symProbMat)) + as.vector(as.dist(newDistMat)) + as.vector(as.dist(smWaves)) + as.vector(as.dist(smNO3)))
install.packages(ecodist)
update.packages(ecodist)
install.packages("ecodist")
install.packages("ecodist")
library(ecodist)
MRM(as.dist(sm) ~ as.dist(symProbMatF) + as.dist(newDistMat) + as.dist(smWaves) + as.dist(smNO3))
Version
R.Version()
